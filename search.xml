<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数的默认参数</title>
      <link href="/2021/03/01/han-shu-de-mo-ren-can-shu/"/>
      <url>/2021/03/01/han-shu-de-mo-ren-can-shu/</url>
      
        <content type="html"><![CDATA[<p>在C++中，函数的形参列表中的形参是可以有默认值的。<br>语法：<code>返回值类型 函数名 (参数= 默认值) {}</code><br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int func(int a = 10, int b = 5, int c = 1) {    return a + b + c;}int main(){    int a = func();    cout << a << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：  </p><pre class="line-numbers language-text"><code class="language-text">16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量引用</title>
      <link href="/2021/03/01/chang-liang-yin-yong/"/>
      <url>/2021/03/01/chang-liang-yin-yong/</url>
      
        <content type="html"><![CDATA[<p>作用：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void printValue(const int& value){    cout << value << endl;}int main(){    int a = 10;    printValue(a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的本质</title>
      <link href="/2021/03/01/yin-yong-de-ben-zhi/"/>
      <url>/2021/03/01/yin-yong-de-ben-zhi/</url>
      
        <content type="html"><![CDATA[<p>本质：引用的本质在C++内部实现是一个指针常量<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void func(int& ref){    ref = 100; //*ref = 100;}int main(){    int a = 10;    int& ref = a;    //int* const ref = &a;    ref = 20;    //*ref = 20;    cout << "a:" << a << endl;    cout << "ref:" << ref << endl;    func(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用做函数返回值</title>
      <link href="/2021/02/27/yin-yong-zuo-han-shu-fan-hui-zhi/"/>
      <url>/2021/02/27/yin-yong-zuo-han-shu-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<p>作用：引用是可以作为函数的返回值存在的<br>注意：不要返回局部变量引用(与之前的”不要返回局部变量的地址”)的原因一样<br>用法：函数调用作为左值<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int& test01(){    static int a = 10;    return a;}int main(){    int& a = test01();    cout << a << endl;    cout << a << endl;    test01() = 1000;    cout << a << endl;    cout << a << endl;    a = 2000;    cout << a << endl;    cout << a << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：  </p><pre class="line-numbers language-text"><code class="language-text">10101000100020002000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用做函数参数</title>
      <link href="/2021/02/26/yin-yong-zuo-han-shu-can-shu/"/>
      <url>/2021/02/26/yin-yong-zuo-han-shu-can-shu/</url>
      
        <content type="html"><![CDATA[<p>当我们想利用形参修饰实参，值传递是做不到的，而可以做到这种操作的，由地址传递和引用传递，在某些情况下，引用传递可以简化指针修改实参，易于使用。<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>void swap01(int& a, int& b){    int temp = a;    a = b;    b = temp;}int main(){    int a = 5;    int b = 10;    std::swap(a, b);    std::cout << "a = " << a << std::endl << "b = " << b << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的注意事项</title>
      <link href="/2021/02/25/yin-yong-de-zhu-yi-shi-xiang/"/>
      <url>/2021/02/25/yin-yong-de-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<p>引用的注意事项：  </p><ol><li>引用必须要初始化<br>示例：<ul><li>错误写法<pre class="line-numbers language-c++"><code class="language-c++">int a = 5;int &b; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>正确写法<pre class="line-numbers language-c++"><code class="language-c++">int a = 5;int &b = 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li>引用一旦初始化后，就不可以更改<br>示例：<pre class="line-numbers language-c++"><code class="language-c++"> int a = 5; int c = 6; int &b = a; b = c; //这个操作实际上是把变量c的值赋值给变量a，而不是引用c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的基本使用</title>
      <link href="/2021/02/25/yin-yong-de-ji-ben-shi-yong/"/>
      <url>/2021/02/25/yin-yong-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>引用的作用：给变量起别名<br><br>语法：数据类型 &amp;别名 = 原名<br><br>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int main(){    int a = 10;    int& b = a;    cout << a << endl;    cout << b << endl;    b = 100;    cout << a << endl;    cout << b << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">1010100100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的new运算符</title>
      <link href="/2021/02/24/c-zhong-de-new-yun-suan-fu/"/>
      <url>/2021/02/24/c-zhong-de-new-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>C++中主要利用new操作符在堆区开辟数据，堆区开辟的数据，由程序员手动开辟&amp;释放，释放时利用操作符delete<br>语法：<code>new 数据类型</code><br><br>利用new创建的数据，会返回该数据对应的类型的指针<br><br>示例1：基本语法</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int* func(){    int * a = new int(10); //new返回是 该数据类型的指针    return a;}int test01(){    int * p = func();    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;    delete p;    //cout << *p << endl; //内存此时已经释放，再次访问属于非法操作，会报错}int main(){    test01();    //堆区的数据由程序员开辟或释放    //如果想释放堆区数据，可利用关键字delete}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：在堆区利用new开辟数组</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void test02(){    int * arr = new int[10]; //这个10代表此数组有10个元素    for(i=0 ; i<10 ; i++)    {        arr[i] = i + 100; //给10个元素分别赋值100~109    }    for(i=0 ; i<10 ; i++)    {        cout << arr[i] << endl;    }    //释放堆区数组    //释放数组要加上[]    delete[] arr;}int main(){    test02();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的堆区</title>
      <link href="/2021/02/23/nei-cun-de-dui-qu/"/>
      <url>/2021/02/23/nei-cun-de-dui-qu/</url>
      
        <content type="html"><![CDATA[<p>堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收<br>在C++中主要用new开辟内存<br>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;//可以利用new关键字将数据开辟到栈区int * func(){    int * p = new int(10); //new关键字会返回开辟到栈区的数据的地址，这时我们可以用指针来接收它    return p; //返回的指针自身本身是个局部变量，在栈区}int main(){    int * p = func();    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">10101010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果说明：只要不去主动释放堆区数据（代码释放或结束程序）它就会一直存在。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的栈区</title>
      <link href="/2021/02/23/nei-cun-de-zhan-qu/"/>
      <url>/2021/02/23/nei-cun-de-zhan-qu/</url>
      
        <content type="html"><![CDATA[<p>栈区：由编译器自动分配释放，存放函数的参数值、局部变量等<br>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int* func(){    int a = 10;    return &a;}int main(){    int * p = func();    cout << *p << endl;    cout << *p << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">10267955168<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时说明在第一次打印*p时编译器保留了局部变量a<br>但在第二次打印时数据不再保留<br>所以永远不要去返回局部变量的地址，形参数据也不要尝试返回它的地址</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的全局区</title>
      <link href="/2021/02/21/nei-cun-de-quan-ju-qu/"/>
      <url>/2021/02/21/nei-cun-de-quan-ju-qu/</url>
      
        <content type="html"><![CDATA[<p>全局区的特点：全局区存放着全局变量和静态变量，还包含着常量区()，且该区域的数据在程序结束后由操作系统释放。</p><pre class="line-numbers language-c++"><code class="language-c++">//全局变量int a = 1;//const修饰的全局变量（全局常量）const int e = 1;int main(){    //局部变量    int b = 1;    //静态变量    static int c = 1;    //字符串常量    "一段字符"    //const修饰的局部变量（局部常量）    const int d = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>局部常量与局部变量在同一个区域内。<br>全局变量、静态变量、字符串变量、全局常量在一个区域（全局区）内。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
