<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>类和对象-对象特性-构造函数调用规则</title>
      <link href="/2021/03/20/lei-he-dui-xiang-dui-xiang-te-xing-gou-zao-han-shu-diao-yong-gui-ze/"/>
      <url>/2021/03/20/lei-he-dui-xiang-dui-xiang-te-xing-gou-zao-han-shu-diao-yong-gui-ze/</url>
      
        <content type="html"><![CDATA[<p>默认情况下，c++编译器至少给一个类添加3个函数</p><ol><li><p>默认构造函数(无参，函数体为空)</p></li><li><p>默认析构函数(无参，函数体为空)</p></li><li><p>默认拷贝构造函数，对属性进行值拷贝</p></li></ol><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p><pre class="line-numbers language-c++"><code class="language-c++">class Person {public:  //无参（默认）构造函数  Person() {      cout << "无参构造函数!" << endl;  }  //有参构造函数  Person(int a) {      age = a;      cout << "有参构造函数!" << endl;  }  //拷贝构造函数  Person(const Person& p) {      age = p.age;      cout << "拷贝构造函数!" << endl;  }  //析构函数  ~Person() {      cout << "析构函数!" << endl;  }public:  int age;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>void test01()<br>{<br>    Person p1(18);<br>    //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作<br>    Person p2(p1);</p><pre><code>cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</code></pre><p>}</p><p>void test02()<br>{<br>    //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造<br>    Person p1; //此时如果用户自己没有提供默认构造，会出错<br>    Person p2(10); //用户提供的有参<br>    Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供</p><pre><code>//如果用户提供拷贝构造，编译器不会提供其他构造函数Person p4; //此时如果用户自己没有提供默认构造，会出错Person p5(10); //此时如果用户自己没有提供有参，会出错Person p6(p5); //用户自己提供拷贝构造</code></pre><p>}</p><p>int main() {</p><pre><code>test01();system(&quot;pause&quot;);return 0;</code></pre><p>}</p><p>```</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-对象特性-拷贝构造函数调用时机</title>
      <link href="/2021/03/18/lei-he-dui-xiang-dui-xiang-te-xing-kao-bei-gou-zao-han-shu-diao-yong-shi-ji/"/>
      <url>/2021/03/18/lei-he-dui-xiang-dui-xiang-te-xing-kao-bei-gou-zao-han-shu-diao-yong-shi-ji/</url>
      
        <content type="html"><![CDATA[<p>拷贝构造函数调用时机<br>C++中拷贝构造函数调用时机通常有三种情况  </p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象  </li><li>值传递的方式给函数参数传值  </li><li>以值方式返回局部对象<br>示例：  <pre class="line-numbers language-c++"><code class="language-c++">class Person {public:  Person() {      cout << "无参构造函数!" << endl;      mAge = 0;  }  Person(int age) {      cout << "有参构造函数!" << endl;      mAge = age;  }  Person(const Person& p) {      cout << "拷贝构造函数!" << endl;      mAge = p.mAge;  }  //析构函数在释放内存之前调用  ~Person() {      cout << "析构函数!" << endl;  }public:  int mAge;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>//1. 使用一个已经创建完毕的对象来初始化一个新对象<br>void test01() {</p><pre><code>Person man(100); //p对象已经创建完毕Person newman(man); //调用拷贝构造函数Person newman2 = man; //拷贝构造//Person newman3;//newman3 = man; //不是调用拷贝构造函数，赋值操作</code></pre><p>}</p><p>//2. 值传递的方式给函数参数传值<br>//相当于Person p1 = p;<br>void doWork(Person p1) {}<br>void test02() {<br>    Person p; //无参构造函数<br>    doWork(p);<br>}</p><p>//3. 以值方式返回局部对象<br>Person doWork2()<br>{<br>    Person p1;<br>    cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;<br>    return p1;<br>}</p><p>void test03()<br>{<br>    Person p = doWork2();<br>    cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;<br>}</p><p>int main() {</p><pre><code>//test01();//test02();test03();system(&quot;pause&quot;);return 0;</code></pre><p>}<br>```</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-对象特性-函数的分类以及调用</title>
      <link href="/2021/03/16/lei-he-dui-xiang-dui-xiang-te-xing-han-shu-de-fen-lei-yi-ji-diao-yong/"/>
      <url>/2021/03/16/lei-he-dui-xiang-dui-xiang-te-xing-han-shu-de-fen-lei-yi-ji-diao-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>两种分类方式</strong>：</p><p>​按参数分为： 有参构造和无参构造</p><p>​按类型分为： 普通构造和拷贝构造</p><p><strong>三种调用方式</strong>：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><p>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">//1、构造函数分类// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person {public:    //无参（默认）构造函数    Person() {        cout << "无参构造函数!" << endl;    }    //有参构造函数    Person(int a) {        age = a;        cout << "有参构造函数!" << endl;    }    //拷贝构造函数    Person(const Person& p) {        age = p.age;        cout << "拷贝构造函数!" << endl;    }    //析构函数    ~Person() {        cout << "析构函数!" << endl;    }public:    int age;};//2、构造函数的调用//调用无参构造函数void test01() {    Person p; //调用无参构造函数}//调用有参的构造函数void test02() {    //2.1  括号法，常用    Person p1(10);    //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明    //Person p2();    //2.2 显式法    Person p2 = Person(10);     Person p3 = Person(p2);    //Person(10)单独写就是匿名对象  当前行结束之后，马上析构    //2.3 隐式转换法    Person p4 = 10; // Person p4 = Person(10);     Person p5 = p4; // Person p5 = Person(p4);     //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明    //Person p5(p4);}int main() {    test01();    //test02();    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-对象特性-构造函数和析构函数</title>
      <link href="/2021/03/14/lei-he-dui-xiang-dui-xiang-te-xing-gou-zao-han-shu-he-xi-gou-han-shu/"/>
      <url>/2021/03/14/lei-he-dui-xiang-dui-xiang-te-xing-gou-zao-han-shu-he-xi-gou-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h2><p>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</p><h2 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h2><p>对象的初始化和清理也是两个非常重要的安全问题</p><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p><p>编译器提供的构造函数和析构函数是空实现。</p><p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p><p>构造函数，没有返回值也不写void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p><p>析构函数，没有返回值也不写void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次  </p><pre class="line-numbers language-c++"><code class="language-c++">class Person{public:    Person()    {        cout << "Person的构造函数被调用" << endl;    }    ~Person()    {        cout << "Person的析构函数被调用" << endl;    }};void test01(){    Person P1;}int main(){    test01();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-封装-成员属性私有化</title>
      <link href="/2021/03/11/lei-he-dui-xiang-feng-zhuang-cheng-yuan-shu-xing-si-you-hua/"/>
      <url>/2021/03/11/lei-he-dui-xiang-feng-zhuang-cheng-yuan-shu-xing-si-you-hua/</url>
      
        <content type="html"><![CDATA[<p>优点一：将所有成员属性设置为私有，可以自己控制读写权限<br>优点二：对于写权限，我们可以检测数据的有效性<br>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">class Person{public:    int GetRO() //只读    {        return ro;    }    int SetWO(int value) //只写    {        wo = value;    }    int SetRW(int value) //可读写    {        rw = value;    }    int GetRW() //可读写    {        return rw;    }private:    int ro = 10;    int wo = 10;    int rw = 10;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-封装-C++中class和struct的区别</title>
      <link href="/2021/03/10/lei-he-dui-xiang-feng-zhuang-c-zhong-class-he-struct-de-qu-bie/"/>
      <url>/2021/03/10/lei-he-dui-xiang-feng-zhuang-c-zhong-class-he-struct-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>在C++中struct和class的<strong>唯一区别</strong>就在于<strong>默认访问权限不同</strong><br>区别：  </p><ul><li>class的默认权限为私有</li><li>struct的默认权限为公共</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-封装-访问权限</title>
      <link href="/2021/03/09/lei-he-dui-xiang-feng-zhuang-fang-wen-quan-xian/"/>
      <url>/2021/03/09/lei-he-dui-xiang-feng-zhuang-fang-wen-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>访问权限有三种：<br>public &ensp;&nbsp;&nbsp;&nbsp;&nbsp;公共权限 成员 类内可以访问 类外可以访问<br>protected 保护权限 成员 类内可以访问 类外不可以访问  子类可以访问父类的保护内容<br>private &ensp;&ensp;&nbsp;私有权限 成员 类内可以访问 类外不可以访问 子类不可以访问父类的保护内容<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <string>using namespace std;class Person{public:    string m_Name;protected:    string m_Car;private:    int passwd;public:    void func()    {        m_Name = "张三";        m_Car = "垃圾车";        passwd = 123456;    }};int main(){    Person p1;    p1.m_Name = "李四";    //p1.m_Car = "自行车"; 保护权限内容,类外禁止访问    //p1.passwd = 159756; 私有权限内容,类外禁止访问}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和对象-封装-属性和行为作为整体</title>
      <link href="/2021/03/06/lei-he-dui-xiang-feng-zhuang-shu-xing-he-xing-wei-zuo-wei-zheng-ti/"/>
      <url>/2021/03/06/lei-he-dui-xiang-feng-zhuang-shu-xing-he-xing-wei-zuo-wei-zheng-ti/</url>
      
        <content type="html"><![CDATA[<p>C++面向对象的三大特性为：封装、继承和多态<br>C++认为万事万物都皆为对象，对象上有其属性和行为<br>具有相同性质的类，我们可以抽象称为类  </p><h1 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h1><h2 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1 封装的意义"></a>4.1.1 封装的意义</h2><p>封装是C++面向对象三大特性之一<br>封装的意义：  </p><ul><li>将属性和行为作为一个整体，表现生活中的事物  </li><li>将属性和行为加以权限控制  </li></ul><p><strong>封装意义一</strong>：<br>&emsp;&emsp;&nbsp;&ensp;在设计类的时候，将属性和行为写在一起，表现事物<br><strong>语法</strong>：<code>class 类名{ 访问权限: 属性 / 行为 };</code><br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;const double PI = 3.14;class Circle{    //访问权限public:    //属性    //类中的属性和行为统一称为成员    //属性 成员属性 成员变量    //行为 成员函数 成员方法    double radius;    //行为    double ReturnRadius()     {        return 2 * PI * radius;    }};int main(){    Circle c1; //实例化(通过类创建一个对象的过程)    c1.radius = 5.3; //给对象的属性赋值    cout << "圆的周长为:" << c1.ReturnRadius() << " cm" <<endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载-注意事项</title>
      <link href="/2021/03/04/han-shu-chong-zai-zhu-yi-shi-xiang/"/>
      <url>/2021/03/04/han-shu-chong-zai-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<p><strong>注意事项</strong>：  </p><ol><li>引用作为重载的条件<br>示例：<pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream> using namespace std; void func(const int &a)  {     cout << "This is func(const int &a)" << endl; } void func(int &a) {     cout << "This is func(int a)" <<endl; } int main() {     int a = 10;     func(a); //此时会输出"This is func(int a)"     func(10); //此时会输出"This is func(const int &a)",如果用const修饰的int变量引入与此等效 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>函数重载碰到默认参数<br>示例：  <pre class="line-numbers language-c++"><code class="language-c++"> #include <iostream> using namespace std; void func(int a,int b = 10)  {     cout << "This is func(int a,int b = 10)" << endl; } void func(int a) {     cout << "This is func(int a)" <<endl; } int main() {     //func(10); //此行会报编译错误，因为函数会出现二义性导致编译器无法判断到底执行哪一个函数     func(10, 20); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载</title>
      <link href="/2021/03/02/han-shu-chong-zai-ji-ben-yu-fa/"/>
      <url>/2021/03/02/han-shu-chong-zai-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>作用</strong>：函数名可以相同，提高复用性<br><strong>函数重载满足条件：</strong>  </p><ul><li>在同一个作用域下</li><li>函数名称相同</li><li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>  </li></ul><p><strong>注意</strong>：函数的返回值不可以作为函数重载的条件<br><strong>示例</strong>：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void func(int a, int b) {    cout << "This is a func" << a << b << endl;}void func(int a){    cout << "This is a func" << a << endl;}int main(){    func(123, 456);    func(789012);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的占位参数</title>
      <link href="/2021/03/02/han-shu-de-zhan-wei-can-shu/"/>
      <url>/2021/03/02/han-shu-de-zhan-wei-can-shu/</url>
      
        <content type="html"><![CDATA[<p>C++函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置<br>语法：返回值类型 函数名 (数据类型){}<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void func(int a, int) {    cout << "This is a func" << endl;}void func1(int a, int = 10) //占位参数同样可以有默认值{    return;}int main(){    func(10, 10);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的默认参数</title>
      <link href="/2021/03/01/han-shu-de-mo-ren-can-shu/"/>
      <url>/2021/03/01/han-shu-de-mo-ren-can-shu/</url>
      
        <content type="html"><![CDATA[<p>在C++中，函数的形参列表中的形参是可以有默认值的。<br>语法：<code>返回值类型 函数名 (参数= 默认值) {}</code><br>注意事项：</p><ol><li>如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值  </li><li>如果函数声明有默认参数，函数实现就不能有默认参数（声明和实现只能有一个有默认参数）<br> 错误示范： <pre class="line-numbers language-c++"><code class="language-c++"> int func(int a = 10,int b = 10); int func(int a = 10,int b = 10)//C++中不允许重定义函数的默认参数 {     return a + b; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> 正确操作：<pre class="line-numbers language-c++"><code class="language-c++"> int func(int a = 10,int b = 10); int func(int a,int b)//C++中不允许重定义函数的默认参数 {     return a + b; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int func(int a = 10, int b = 5, int c = 1) {    return a + b + c;}int main(){    int a = func();    cout << a << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：  </p><pre class="line-numbers language-text"><code class="language-text">16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量引用</title>
      <link href="/2021/03/01/chang-liang-yin-yong/"/>
      <url>/2021/03/01/chang-liang-yin-yong/</url>
      
        <content type="html"><![CDATA[<p>作用：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void printValue(const int& value){    cout << value << endl;}int main(){    int a = 10;    printValue(a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的本质</title>
      <link href="/2021/03/01/yin-yong-de-ben-zhi/"/>
      <url>/2021/03/01/yin-yong-de-ben-zhi/</url>
      
        <content type="html"><![CDATA[<p>本质：引用的本质在C++内部实现是一个指针常量<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void func(int& ref){    ref = 100; //*ref = 100;}int main(){    int a = 10;    int& ref = a;    //int* const ref = &a;    ref = 20;    //*ref = 20;    cout << "a:" << a << endl;    cout << "ref:" << ref << endl;    func(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用做函数返回值</title>
      <link href="/2021/02/27/yin-yong-zuo-han-shu-fan-hui-zhi/"/>
      <url>/2021/02/27/yin-yong-zuo-han-shu-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<p>作用：引用是可以作为函数的返回值存在的<br>注意：不要返回局部变量引用(与之前的”不要返回局部变量的地址”)的原因一样<br>用法：函数调用作为左值<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int& test01(){    static int a = 10;    return a;}int main(){    int& a = test01();    cout << a << endl;    cout << a << endl;    test01() = 1000;    cout << a << endl;    cout << a << endl;    a = 2000;    cout << a << endl;    cout << a << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：  </p><pre class="line-numbers language-text"><code class="language-text">10101000100020002000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用做函数参数</title>
      <link href="/2021/02/26/yin-yong-zuo-han-shu-can-shu/"/>
      <url>/2021/02/26/yin-yong-zuo-han-shu-can-shu/</url>
      
        <content type="html"><![CDATA[<p>当我们想利用形参修饰实参，值传递是做不到的，而可以做到这种操作的，由地址传递和引用传递，在某些情况下，引用传递可以简化指针修改实参，易于使用。<br>示例：  </p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>void swap01(int& a, int& b){    int temp = a;    a = b;    b = temp;}int main(){    int a = 5;    int b = 10;    std::swap(a, b);    std::cout << "a = " << a << std::endl << "b = " << b << std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的注意事项</title>
      <link href="/2021/02/25/yin-yong-de-zhu-yi-shi-xiang/"/>
      <url>/2021/02/25/yin-yong-de-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<p>引用的注意事项：  </p><ol><li>引用必须要初始化<br>示例：<ul><li>错误写法<pre class="line-numbers language-c++"><code class="language-c++">int a = 5;int &b; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>正确写法<pre class="line-numbers language-c++"><code class="language-c++">int a = 5;int &b = 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li>引用一旦初始化后，就不可以更改<br>示例：<pre class="line-numbers language-c++"><code class="language-c++"> int a = 5; int c = 6; int &b = a; b = c; //这个操作实际上是把变量c的值赋值给变量a，而不是引用c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用的基本使用</title>
      <link href="/2021/02/25/yin-yong-de-ji-ben-shi-yong/"/>
      <url>/2021/02/25/yin-yong-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>引用的作用：给变量起别名<br><br>语法：数据类型 &amp;别名 = 原名<br><br>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int main(){    int a = 10;    int& b = a;    cout << a << endl;    cout << b << endl;    b = 100;    cout << a << endl;    cout << b << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">1010100100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的new运算符</title>
      <link href="/2021/02/24/c-zhong-de-new-yun-suan-fu/"/>
      <url>/2021/02/24/c-zhong-de-new-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<p>C++中主要利用new操作符在堆区开辟数据，堆区开辟的数据，由程序员手动开辟&amp;释放，释放时利用操作符delete<br>语法：<code>new 数据类型</code><br><br>利用new创建的数据，会返回该数据对应的类型的指针<br><br>示例1：基本语法</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int* func(){    int * a = new int(10); //new返回是 该数据类型的指针    return a;}int test01(){    int * p = func();    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;    delete p;    //cout << *p << endl; //内存此时已经释放，再次访问属于非法操作，会报错}int main(){    test01();    //堆区的数据由程序员开辟或释放    //如果想释放堆区数据，可利用关键字delete}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：在堆区利用new开辟数组</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;void test02(){    int * arr = new int[10]; //这个10代表此数组有10个元素    for(i=0 ; i<10 ; i++)    {        arr[i] = i + 100; //给10个元素分别赋值100~109    }    for(i=0 ; i<10 ; i++)    {        cout << arr[i] << endl;    }    //释放堆区数组    //释放数组要加上[]    delete[] arr;}int main(){    test02();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的堆区</title>
      <link href="/2021/02/23/nei-cun-de-dui-qu/"/>
      <url>/2021/02/23/nei-cun-de-dui-qu/</url>
      
        <content type="html"><![CDATA[<p>堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收<br>在C++中主要用new开辟内存<br>示例：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;//可以利用new关键字将数据开辟到栈区int * func(){    int * p = new int(10); //new关键字会返回开辟到栈区的数据的地址，这时我们可以用指针来接收它    return p; //返回的指针自身本身是个局部变量，在栈区}int main(){    int * p = func();    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;    cout << *p << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">10101010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果说明：只要不去主动释放堆区数据（代码释放或结束程序）它就会一直存在。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的栈区</title>
      <link href="/2021/02/23/nei-cun-de-zhan-qu/"/>
      <url>/2021/02/23/nei-cun-de-zhan-qu/</url>
      
        <content type="html"><![CDATA[<p>栈区：由编译器自动分配释放，存放函数的参数值、局部变量等<br>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int* func(){    int a = 10;    return &a;}int main(){    int * p = func();    cout << *p << endl;    cout << *p << endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-text"><code class="language-text">10267955168<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时说明在第一次打印*p时编译器保留了局部变量a<br>但在第二次打印时数据不再保留<br>所以永远不要去返回局部变量的地址，形参数据也不要尝试返回它的地址</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存的全局区</title>
      <link href="/2021/02/21/nei-cun-de-quan-ju-qu/"/>
      <url>/2021/02/21/nei-cun-de-quan-ju-qu/</url>
      
        <content type="html"><![CDATA[<p>全局区的特点：全局区存放着全局变量和静态变量，还包含着常量区()，且该区域的数据在程序结束后由操作系统释放。</p><pre class="line-numbers language-c++"><code class="language-c++">//全局变量int a = 1;//const修饰的全局变量（全局常量）const int e = 1;int main(){    //局部变量    int b = 1;    //静态变量    static int c = 1;    //字符串常量    "一段字符"    //const修饰的局部变量（局部常量）    const int d = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>局部常量与局部变量在同一个区域内。<br>全局变量、静态变量、字符串变量、全局常量在一个区域（全局区）内。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
